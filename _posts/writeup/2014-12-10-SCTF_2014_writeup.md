---
layout: post
title: SCTF-2014 writeup
category: writeup
tags: ctf
keywords: 
description: 
---

## code200: 

![code200](/public/img/2014-12-10-SCTF-2014_writeup-1.jpg)

个题目看着描述很复杂，实际上把数字转成二进制，输出二进制位上是 1 的位置序号就可以了。需要注意的是奇偶位是有符号的，如果最高位序号是奇数，需要在前面补一个偶数位。
编程的任务等待以后python练习的时候补吧。

## code400:

![code400](/public/img/2014-12-10-SCTF-2014_writeup-2.jpg)

```python

import json
import hashlib
import os
import base64
from Crypto.Cipher import AES
 
fp = open("secret.json", "r")
secret = json.load(fp)
fp.close()
 
if type(secret["the answer to life the universe and everything"]) != type(u"77"):
    destroy_the_universe()
 
answer = hashlib.sha1(secret["the answer to life the universe and everything"]).hexdigest()[0:16]
key = hashlib.sha1(secret["Don't google what it is"]).digest()[0:6]
 
if ord(key[4])*(ord(key[5])-5) != 17557:
    destroy_the_universe()
 
keys = ["hey"+key[2]+"check"+key[3]+"it"+key[0]+"out", 
        "come"+key[1]+"on"+key[4]+"baby"+key[5]+"~~!"]
answer = AES.new(keys[1], AES.MODE_ECB).encrypt(AES.new(keys[0], AES.MODE_ECB).encrypt(answer))
 
if base64.b64encode(answer) == "fm2knkCBHPuhCQHYE3spag==":
    fp = open("%s.txt" % hashlib.sha256(key).hexdigest(), "w")
    fp.write(secret["The entrance to the new world"])
    fp.close()
```
很明显这个题目是要爆破的。首先计算出k[4]和k[5],对17557做因式分解：97\*181。
因而存在两组可能k[4]=97, k[5]=186;k[4]=102, k[5]=181。需要分别爆破。
这里有个可以优化的地方，就是在对应一组k[4]和k[5]的情况下keys[1]只有256种可能，可以先解出keys[1]对应的256个答案的解，也就是破解出最外面那一层AES，而后keys[0]对应的DES进行爆破的时候，结果只要查keys[1]对应的256长度的答案表就可以了。虽然算法复杂度依然是255\*255*255\*255，但最外面那一层没有计算AES，速度要快一些。
实际上直接暴力也可以。

```python
import hashlib
import base64
from Crypto.Cipher import AES
k4=102
k5=181
kkk = hashlib.sha1("42").hexdigest()[0:16]
for k0 in range(255, 256):
    for k1 in range(0, 256):
        for k2 in range(0, 256):
            for k3 in range(0, 256):
                keys = ["hey"+chr(k2)+"check"+chr(k3)+"it"+chr(k0)+"out",
                        "come"+chr(k1)+"on"+chr(k4)+"baby"+chr(k5)+"~~!"]
                #print len(keys[0]), len(keys[1])
                answer = AES.new(keys[1], AES.MODE_ECB).encrypt(AES.new(keys[0], AES.MODE_ECB).encrypt(kkk))
                if base64.b64encode(answer) == "fm2knkCBHPuhCQHYE3spag==":
                    print "%s.txt" % hashlib.sha256(chr(k0)+chr(k1)+chr(k2)+chr(k3)+chr(k4)+chr(k5)).hexdigest()
                    exit();
```